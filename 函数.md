# 函数

---

**函数定义方式**
1. 通过函数声明的形式来定义
2. 通过函数表达式的形式来定义
3. 通过Function构造函数实例化的形式来定义

通过Function构造函数定义函数
1. 可以传入任意数量的实参
2. 最后一个实参为函数体
3. 函数体中 javascript 语句之间分号隔开
4. Function 构造函数创建一个匿名函数

**函数对象中的关键字**
形参(Parameters) 是函数定义时的形式参数，作为函数定义的一部分，是列出类的变量。
实参(Arguments) 是函数调用时的实际参数，是在函数被调用时传递给该函数的变量值。

arguments 
是一个对应于传递给函数的参数的类数组对象
所有（非箭头）函数中都可用的局部变量

arguments与形参的“双向绑定”特性
1. 向函数传递参数时，arguments 数组中的对应单元会和命名参数建立关联（linkage）以得到相同的值。相反，不传递参数就不会建立关联。
2. 在调用时 arguments 对象与实际传递了值的形参变量发生双向绑定

arguments 的 length 属性
1. 每个函数都有一个 arguments 关键字，表示执行函数调用时实际传入的参数的集合，即函数的实参集合。
2. 在调用时，实参个数确定， arguments.length确定， 不会再发生改变。

this
1. 在 function 内部被创建
2. 指向调用时所在函数所绑定的对象
3. this 不能被赋值，但可以被 call/apply/bind  改变
4. 在 JavaScript 中，this 是动态绑定，或称为运行期绑定的。由于其运行期绑定的特性，JavaScript 中的 this 含义很丰富，它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。

---

####函数对象中方法

**函数**
函数是对象，对象是一系列属性和方法的集合。

方法
1. this 通常是被自动赋值的，但是我们可以改变 this 的指向，JavaScript 给我们提供了 3 种函数方法来改变 this 的指向。
2. call、apply、bind 
3. toString、valueOf

属性
1. name、length
2. prototype、____proto____

**call方法**
call() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数列表) —— fn.call(thisObj,arg1,arg2,...)
1. thisObj: 将函数对象中的 this 指向 thisObj 对象
如果未传递，this 指向全局对象 window
如果传递为 undefined/null，this 指向全局对象 window
如果传递为原始值(数字，字符串，布尔值)，this 指向该原始值的包装对象
2. arg1,arg2,...: 被调用函数的实参

**apply方法**
apply() 方法调用一个函数, 其具有一个指定的 this 值和作为数组提供的参数(参数数组) —— fn.apply(thisObj,[arg1,arg2,...])
1. thisObj: 将函数对象中的 this 指向 thisObj 对象
如果未传递，this 指向全局对象 window
如果传递为 undefined/null，this 指向全局对象 window
如果传递为原始值(数字，字符串，布尔值)，this 指向该原始值的包装对象
2. [arg1,arg2,...]: 被调用函数的实参

**bind方法**
bind() 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项 —— fn.bind(thisObj,arg1,arg2,...)
返回值：返回一个原函数的拷贝，并拥有指定的this值和初始参数。

**tostring、valueOf**
fn.toString() 方法返回一个表示当前函数源代码的字符串。
fn.valueOf() 方法返回函数本身。 
函数的计算:
 与 Number 结合计算
 与 String 结合计算
 与 Boolean 结合计算

---

####函数对象的属性

**name、length**
fn.name 属性返回函数的名称
fn.length 属性指明函数的形参个数
arguments.length 是函数被调用时实参个数

**prototype / ____proto____**
每个函数都有一个 prototype 属性，指向一个对象。
每个对象实例都有一个__proto__属性，指向它的原型对象。
对象的原型是由创建并初始化该对象的构造函数定义的

---

####函数的调用

**函数调用形式（4种）**
1. 作为函数直接调用
2. 作为对象方法调用
3. 作为构造函数调用
4. 通过call/apply间接调用

**执行上下文（execution context）**
 函数每调用一次，就会创建一个新的执行上下文
 函数执行结束，相应的执行上下文销毁

**执行上下文栈（Execution context stack，ECS）**
执行上下文栈按照函数的调用顺序来管理执行上下文
栈底永远是全局上下文，栈顶是当前正在执行的函数

**调用栈（Call Stack）**
代码执行时JavaScript 引擎会以栈的方式来处理和追踪函数调用
栈底对应的是全局上下文环境，而栈顶对应的是当前正在执行的上下文环境

**return 语句的作用**
返回值
终止函数的执行 ——销毁当前执行上下文，弹出调用栈

**变量对象（Variable Object）**
函数的所有形参
当前上下文中的所有函数声明
当前上下文中所有变量声明

**预编译（预解析）**
JavaScript代码的整个执行过程
1. JavaScript 引擎是一段一段地运行代码的  ——函数
2. 执行每一段代码之前，都有一个“预编译”
JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段  ——预编译的任务：声明提升
1. 编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。
2. 执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。

**活动对象（Activation Object）**：执行阶段的变量对象

**浏览器中的全局上下文的变量对象**
 变量对象就是 window 对象  windowEC.VO = window
 不会变成活动对象
 在页面关闭前一直存在

**作用域链（Scope Chain）**
由当前执行环境与上层（父级）执行环境的一系列变量对象组成
提供对变量和函数访问的权限和顺序的规则

**作用域链与执行上下文**
1. 执行时，当前执行上下文，对应一个作用域链环境来管理和解析变量和函数（动态性）
2. 变量查找按照由内到外的顺序（遵循词法作用域），直到完成查找，若未查询到则报错
3. 当函数执行结束，运行期上下文被销毁，此作用域链环境也随之被释放

**变量的管理**
1. 当程序运行到变量所在的作用域时，变量被创建，此时需要一个存储的空间
2. JS中提供存储空间的数据结构被称为环境，每个函数都有自己的执行环境
3. 每个执行环境都有一个与之关联的变量对象，环境中所有变量和函数都保存在此对象中
4. Web浏览器中，全局执行环境为window对象

**作用域链（在 ECMA262 中的解释，涉及到内部属性）**
任何执行上下文时刻的作用域，都是由作用域链 (scope chain) 来实现。 在一个函数被定义的时候，会将它定义时候的 scope chain 链接到这个函数对象的[[scope]]属性。在一个函数对象被调用的时候，会创建一个活动对象 (也就是一个对象，然后对于每一个函数的形参，都命名为该活动对象的命名属性，然后将这个活动对象做为此时的作用域链 (scope chain) 最前端， 并将这个函数对象的 [[scope]] 加入到 scope chain 中












